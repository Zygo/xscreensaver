#!/usr/bin/perl -w
# Copyright © 2001-2010 Jamie Zawinski <jwz@jwz.org>.
#
# Permission to use, copy, modify, distribute, and sell this software and its
# documentation for any purpose is hereby granted without fee, provided that
# the above copyright notice appear in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation.  No representations are made about the suitability of this
# software for any purpose.  It is provided "as is" without express or 
# implied warranty.
#
# This program attempts to grab a single frame of video from the system's
# video capture card, and then load it on to the root window using the
# "xscreensaver-getimage-file" program.  Various frame-grabbing programs
# are known, and the first one found is used.
#
# The various xscreensaver hacks that manipulate images ("slidescreen",
# "jigsaw", etc.) get the image to manipulate by running the
# "xscreensaver-getimage" program.
#
# "xscreensaver-getimage" will invoke this program, depending on the
# value of the "grabVideoFrames" setting in the ~/.xscreensaver file
# (or in /usr/lib/X11/app-defaults/XScreenSaver).
#
# Created: 13-Apr-2001.

require 5;
#use diagnostics;	# Fails on some MacOS 10.5 systems
use strict;

my $progname = $0; $progname =~ s@.*/@@g;
my $version  = q{ $Revision: 1.19 $ }; $version =~ s/^[^0-9]+([0-9.]+).*$/$1/;

my $tmpdir   = $ENV{TMPDIR} || "/tmp";
my $tmpfile  = sprintf("%s/xssv.%08x.ppm", $tmpdir, rand(0xFFFFFFFF));

my $verbose           = 0;
my $use_stdout_p      = 0;
my $return_filename_p = 0;


# These are programs that can be used to grab a video frame.  The first one
# of these programs that exists on $PATH will be used, and the image file
# is assumed to be written to $tmpfile (in some image format acceptable to
# "xscreensaver-getimage-file", e.g., PPM or JPEG.)
#
# If you add other programs to this list, please let me know!
#
my @programs = (

  "bttvgrab -d q -Q -l 1 -o ppm -f $tmpfile",	# BTTV
  "qcam > $tmpfile",				# Connectix Qcam
  "gqcam -t PPM -d $tmpfile",			# GTK+ Qcam clone

  "v4lctl snap ppm full $tmpfile",		# XawTV 3.94.

  "streamer -a -s 768x576 -o $tmpfile",		# XawTV
  #   the "-a" option ("mute audio") arrived with XawTV 3.76.

  "atitv snap $tmpfile",			# ATI video capture card

  "grab -type ppm -format ntsc -source 1 " .	# *BSD BT848 module
	"-settle 0.75 -output $tmpfile",

  "motioneye -j $tmpfile",			# Sony Vaio MotionEye
						# (hardware jpeg encoder)

  "vidcat -b -f ppm -s 640x480 > $tmpfile 2>-",	# w3cam/ovcam

  "vidtomem -f $tmpfile 2>&- " .		# Silicon Graphics
	"&& mv $tmpfile-00000.rgb $tmpfile",

  # "mplayer tv:// -vo pnm -frames 1 2>&- " .	# Maybe works with some cams?
  #	"&& mv 00000001.ppm $tmpfile",
);


sub error($) {
  my ($e) = @_;
  print STDERR "$progname: $e\n";
  exit 1;
}

sub pick_grabber() {
  my @names = ();

  foreach my $cmd (@programs) {
    $_ = $cmd;
    my ($name) = m/^([^ ]+)/;
    push @names, "\"$name\"";
    print STDERR "$progname: looking for $name...\n" if ($verbose > 2);
    foreach my $dir (split (/:/, $ENV{PATH})) {
      print STDERR "$progname:   checking $dir/$name\n" if ($verbose > 3);
      if (-x "$dir/$name") {
        return $cmd;
      }
    }
  }

  $names[$#names] = "or " . $names[$#names];
  error ("none of: " . join (", ", @names) . " were found on \$PATH.");
}


sub grab_image() {
  my $cmd = pick_grabber();
  unlink $tmpfile;

  print STDERR "$progname: executing \"$cmd\"\n" if ($verbose);
  system ($cmd);

  if (-z $tmpfile)
    {
      unlink $tmpfile;
      error ("\"$cmd\" produced no data.");
    }

  if ($return_filename_p) {
    print STDERR "$progname: wrote \"$tmpfile\"\n" if ($verbose);
    print STDOUT "$tmpfile\n";

  } elsif ($use_stdout_p) {
    local *IN;
    my $ppm = "";
    my $reader  = "<$tmpfile";

    # horrid kludge for SGIs, since they don't use PPM...
    if ($cmd =~ m/^vidtomem\s/) {
      $reader = "sgitopnm $tmpfile";
      $reader .= " 2>/dev/null" if ($verbose <= 1);
      $reader .= " |";
    }

    open(IN, $reader) || error ("reading $tmpfile: $!");
    print STDERR "$progname: reading $tmpfile\n" if ($verbose > 1);
    while (<IN>) { $ppm .= $_; }
    close IN;
    unlink $tmpfile;
    print STDOUT $ppm;

  } else {

    $cmd = "xscreensaver-getimage-file";
    $cmd .= " --verbose" if ($verbose);
    $cmd .= " $tmpfile";

    print STDERR "$progname: executing \"$cmd\"\n" if ($verbose);
    system ($cmd);

    unlink $tmpfile;
  }
}


sub usage() {
  print STDERR "usage: $progname [--verbose] [--name | --stdout]\n";
  exit 1;
}

sub main() {
  while ($_ = $ARGV[0]) {
    shift @ARGV;
    if ($_ eq "--verbose") { $verbose++; }
    elsif (m/^-v+$/) { $verbose += length($_)-1; }
    elsif (m/^--?stdout$/) { $use_stdout_p = 1; }
    elsif (m/^--?name$/)   { $return_filename_p = 1; }
    elsif (m/^-./) { usage; }
    else { usage; }
  }

  grab_image();
}

main;
exit 0;
